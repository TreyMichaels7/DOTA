<html>

<head>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Variables
        const { RTCPeerConnection, RTCSessionDescription } = window;
        let peerConnection = new RTCPeerConnection();
        let thisSocket = "";
        let remoteSocket = "";
        let isAlreadyCalling = false;
        let activeTracks = [];

        // Init
        var socket = io.connect('https://chatroom.kelden.me/');

        // Offer a call to callee
        async function callUser(socketId) {
            console.log(`Calling ${socketId}...`);
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(new RTCSessionDescription(offer));

            socket.emit("call-user", {
                offer,
                to: socketId
            });
        }

        // Socket functions
        socket.on('connect', (data) => {
            socket.emit('join', 'Hello World from client');
        });

        socket.on('disconnect-call', ({ user }) => {
            if (user == remoteSocket) {
                // Reset Peer connections
                const senders = peerConnection.getSenders();
                senders.forEach((sender) => peerConnection.removeTrack(sender));

                // fails for the new calle when you call again from this reset peer (works for this caller tho, but not who you call)

                isAlreadyCalling = false;
                remoteSocket = "";
                showRemoteVid(false);

                alert(`${user} has left the call.`);
            }
        });

        socket.on("get-user-id", ({ user }) => {
            thisSocket = user;
            console.log(user);
            document.getElementById('user-id').textContent = user;
        });

        socket.on("update-user-list", ({ users }) => {
            let userList = document.getElementById("user-list");
            userList.textContent = "";
            for (let user of users) {
                if (thisSocket != user) {
                    let row = document.createElement("LI");
                    row.textContent = user;
                    row.onclick = () => callUser(user);
                    userList.appendChild(row);
                }
            }
        });

        // Socket Call Functions
        // Receive, Answer, and return video information to caller
        socket.on("call-made", async data => {
            await peerConnection.setRemoteDescription(
                new RTCSessionDescription(data.offer)
            );
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(new RTCSessionDescription(answer));

            // Update Remote Caller ID
            remoteSocket = data.socket;
            showRemoteVid(true, remoteSocket);

            socket.emit("make-answer", {
                answer,
                to: data.socket
            });
        });

        // Receive informtaion from the callee, and call them
        socket.on("answer-made", async data => {
            await peerConnection.setRemoteDescription(
                new RTCSessionDescription(data.answer)
            );

            // Update Remote Caller ID
            remoteSocket = data.socket;
            showRemoteVid(true, remoteSocket);

            // Set up the call both ways
            if (!isAlreadyCalling) {
                callUser(remoteSocket);
                isAlreadyCalling = true;
            }
        });

        // Getting access to the video camera / audio
        var constraints = { video: true, audio: true };

        function successCallback(stream) {
            console.log("Success");
            const localVideo = document.getElementById("local-video");
            if (localVideo) { localVideo.srcObject = stream; }
            localVideo.play();

            stream.getTracks().forEach(track => {
                peerConnection.addTrack(track, stream)
            });
        }

        function errorCallback(error) {
            console.log("navigator.getUserMedia error: ", error);
        }

        navigator.mediaDevices.getUserMedia(constraints)
            .then(successCallback)
            .catch(errorCallback);
        // navigator.getUserMedia = (
        //     navigator.getUserMedia ||
        //     navigator.webkitGetUserMedia ||
        //     navigator.mozGetUserMedia ||
        //     navigator.msGetUserMedia
        // );

        // if (typeof navigator.mediaDevices.getUserMedia === 'undefined') {
        //     navigator.getUserMedia(

        //     );
        // } else {
        //     navigator.mediaDevices.getUserMedia(
        //         { video: true, audio: true },
        //         stream => {
        //             console.log("defined");
        //             const localVideo = document.getElementById("local-video");
        //             if (localVideo) { localVideo.srcObject = stream; }

        //             stream.getTracks().forEach(track => {
        //                 peerConnection.addTrack(track, stream)
        //             });
        //             console.log(stream);
        //         },
        //         error => { console.warn(error.message); }
        //     );
        // }


        peerConnection.ontrack = function ({ streams: [stream] }) {
            const remoteVideo = document.getElementById("remote-video");
            if (remoteVideo) {
                remoteVideo.srcObject = stream;
            }
        };

        // UI Functions
        function showRemoteVid(show, remoteId = "") {
            // Update Remote ID and Show
            document.getElementById('remote-id').textContent = remoteId;
            let remoteContainer = document.getElementById("remote-container");
            let display = show ? "block" : "none";
            remoteContainer.style.display = display;

            // Move Header Logo
            let logo = document.getElementById('logo');
            let activeUsers = document.getElementById('active-users');
            if (show) {
                logo.classList.add("top-right");
                activeUsers.style.display = "none";
            } else {
                logo.classList.remove("top-right");
                activeUsers.style.display = "block";
            }
        }

    </script>

    <style>
        #remote-container {
            display: none;
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: -1;
        }

        #remote-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #remote-container>p {
            position: absolute;
            left: 10;
            top: 0;
            color: white;
        }

        #local-container #local-video {
            position: absolute;
            right: 10;
            bottom: 10;
            width: 25%;
            max-width: 300px;
            border-radius: 5px;
            box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
        }

        #local-container>p {
            position: absolute;
            bottom: 0;
            right: 20;
            z-index: 1;
            color: white;
        }

        .top-right {
            color: white;
            opacity: .5;
            position: absolute;
            top: 10;
            right: 20;
            margin: 0;
        }
    </style>
</head>

<body>
    <h1 id="logo">Dating on the Ave</h1>
    <div id="remote-container">
        <p>Them (<span id="remote-id"></span>)</p>
        <video autoplay class="remote-video" id="remote-video"></video>
    </div>

    <div id="local-container">
        <p>You (<span id="user-id"></span>)</p>
        <video autoplay muted class="local-video" id="local-video"></video>
    </div>

    <div id="active-users">
        <h2>Active Users</h2>
        <ol id="user-list"></ol>
    </div>
</body>

</html>